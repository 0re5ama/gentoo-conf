diff -urp NVIDIA-Linux-x86_64-361.28.orig/kernel/nvidia/nv.c NVIDIA-Linux-x86_64-361.28/kernel/nvidia/nv.c
--- NVIDIA-Linux-x86_64-361.28.orig/kernel/nvidia/nv.c	2015-07-29 05:13:57.000000000 +0200
+++ NVIDIA-Linux-x86_64-361.28/kernel/nvidia/nv.c	2015-08-21 16:44:51.008340178 +0200
@@ -719,7 +719,8 @@ int __init nvidia_init_module(void)
 #endif
 
-    nvidia_stack_t_cache = NV_KMEM_CACHE_CREATE(nvidia_stack_cache_name,
-                                                nvidia_stack_t);
+    nvidia_stack_t_cache = NV_KMEM_CACHE_CREATE_FULL(nvidia_stack_cache_name,
+                                                     sizeof(nvidia_stack_t),
+                                                     0, SLAB_USERCOPY, NULL);
     if (nvidia_stack_t_cache == NULL)
     {
         nv_printf(NV_DBG_ERRORS, "NVRM: stack cache allocation failed!\n");
diff -urp NVIDIA-Linux-x86_64-361.28.orig/kernel/nvidia/nv-mmap.c NVIDIA-Linux-x86_64-361.28/kernel/nvidia/nv-mmap.c
--- NVIDIA-Linux-x86_64-361.28.orig/kernel/nvidia/nv-mmap.c	2015-07-29 05:13:57.000000000 +0200
+++ NVIDIA-Linux-x86_64-361.28/kernel/nvidia/nv-mmap.c	2015-08-21 16:58:15.968297199 +0200
@@ -113,12 +113,12 @@ nvidia_vma_release(struct vm_area_struct
 }
 
 #if defined(NV_VM_OPERATIONS_STRUCT_HAS_ACCESS)
-static int
+static ssize_t
 nvidia_vma_access(
     struct vm_area_struct *vma,
     unsigned long addr,
     void *buffer,
-    int length,
+    size_t length,
     int write
 )
 {
diff -urp NVIDIA-Linux-x86_64-361.28.orig/kernel/nvidia-uvm/uvm_common.c NVIDIA-Linux-x86_64-361.28/kernel/nvidia-uvm/uvm_common.c
--- NVIDIA-Linux-x86_64-361.28.orig/kernel/nvidia-uvm/uvm_common.c	2015-07-29 05:10:08.000000000 +0200
+++ NVIDIA-Linux-x86_64-361.28/kernel/nvidia-uvm/uvm_common.c	2015-08-21 17:00:33.788289841 +0200
@@ -79,7 +79,6 @@ NvBool uvmnext_activated(void)
 #endif // NVIDIA_UVM_NEXT_ENABLED
 
 static dev_t g_uvmBaseDev;
-struct UvmOpsUvmEvents g_exportedUvmOps;
 
 // TODO: This would be easier if RM allowed for multiple registrations, since we
 //       could register UVM-Lite and UVM-Next separately (bug 1372835).
@@ -200,12 +200,19 @@ static NV_STATUS uvmSetupGpuProvider(voi
     NV_STATUS status = NV_OK;
 
-    g_exportedUvmOps.startDevice = uvm_gpu_event_start_device;
-    g_exportedUvmOps.stopDevice  = uvm_gpu_event_stop_device;
-    if (uvmnext_activated())
-        g_exportedUvmOps.isrTopHalf = uvmnext_isr_top_half;
-    else if (uvmfull_activated())
-        g_exportedUvmOps.isrTopHalf = uvmfull_isr_top_half;
-
     // call RM to exchange the function pointers.
-    status = nvUvmInterfaceRegisterUvmCallbacks(&g_exportedUvmOps);
+    if (uvmnext_activated()) {
+        static struct UvmOpsUvmEvents g_exportedUvmOps = {
+            .startDevice = uvm_gpu_event_start_device,
+            .stopDevice  = uvm_gpu_event_stop_device,
+            .isrTopHalf  = uvmnext_isr_top_half,
+        };
+        status = nvUvmInterfaceRegisterUvmCallbacks(&g_exportedUvmOps);
+    } else if (uvmfull_activated()) {
+        static struct UvmOpsUvmEvents g_exportedUvmOps = {
+            .startDevice = uvm_gpu_event_start_device,
+            .stopDevice  = uvm_gpu_event_stop_device,
+            .isrTopHalf  = uvmfull_isr_top_half,
+        };
+        status = nvUvmInterfaceRegisterUvmCallbacks(&g_exportedUvmOps);
+    }
     return status;
